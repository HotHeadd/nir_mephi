= Сравнительный анализ существующих инструментов, механизмов ОС, и аппаратных технологий

Глава посвящена сравнительному анализу существующих инструментов и технологий, используемых для мониторинга памяти в современных вычислительных системах. В ней рассматриваются как аппаратные, так и программные средства, доступные для мониторинга доступа к памяти, с целью их оценки по различным критериям, таким как накладные расходы, охват адресного пространства и области применимости. Проводится анализ технологий, встроенных в ОС Linux, и аппаратных механизмов, с целью определения их сильных и слабых сторон в контексте обеспечения безопасности и производительности. Результаты данного анализа служат основой для последующих рекомендаций по выбору инструментов для мониторинга памяти в различных сценариях использования.

== Аппаратные технологии

=== Аппаратные watchpoints (data breakpoints) по адресу

Аппаратные watchpoints опираются на отладочный контур процессора, который умеет сравнивать адрес фактического обращения к памяти с заранее заданными “сторожевыми” адресами и реагировать синхронным событием в момент совпадения. На практике это реализуется отдельным debug unit, который хранит несколько слотов с адресами и условиями срабатывания, а затем встраивается в конвейер выполнения так, чтобы проверка происходила именно в момент доступа, а не постфактум. Для семейства x86-64 такая логика описывается через механизм debug registers, где адреса размещаются в DR0–DR3, а условия доступа и длина наблюдаемого диапазона кодируются управляющими полями, связанными с DR7, при этом само событие относится к архитектурным debug exceptions @intel_sdm_vol3a_253668 @amd64_apm_vol2_24593_343. На Arm аналогичный смысл имеют watchpoint resources self-hosted debug, где адрес и маскирование задаются в специализированных регистрах watchpoint value/control, а обработчик получает диагностическую информацию через регистры синдрома исключения @armv8a_self_hosted_debug_102120.

Событием для watchpoint является аппаратное исключение отладки, возникающее строго в точке обращения к памяти, попавшей под заданные условия. Важная деталь здесь в том, что условия обычно различают тип операции: запись, чтение или комбинированный режим, а на некоторых архитектурах и режимах возможно и наблюдение исполнения, хотя “исполнение” чаще удобнее ловить через механизмы прав доступа страниц, а не через debug unit. С точки зрения информативности обработчик получает как минимум адрес совпадения и возможность понять, какой тип доступа вызвал событие, а также полный контекст “где именно выполнялся код” через стандартно сохраняемое состояние исключения (адрес текущей инструкции и регистры), что даёт основу для последующей атрибуции к модулю, функции или цепочке вызовов @intel_sdm_vol3a_253668 @amd64_apm_vol2_24593_343.

#figure(
  image("assets/dr.png"),
  caption: [Устройство дебаг-регистров в архитектуре x86],
) <fig:x86-debug-registers>


Сильная сторона watchpoints -- мелкая гранулярность @ost_intermediate_x86_part4. В отличие от страничных механизмов, наблюдение можно привязать к конкретному адресу или к небольшому аппаратно задаваемому диапазону вокруг него, причём диапазон обычно требует выравнивания и задаётся ограниченным набором размеров. Это выглядит как идеальный кандидат для “конкретного доступа к участку памяти”, но дальше быстро проявляется фундаментальное ограничение: число аппаратных слотов очень мало. На x86-64 обычно доступно четыре адресных watchpoint-слота, и даже при аккуратном переиспользовании этого ресурса масштабирование на десятки адресов или на большие диапазоны не получается без динамической перезагрузки конфигурации и дополнительных ухищрений @intel_sdm_vol3a_253668 @amd64_apm_vol2_24593_343. По цене watchpoints удобны, пока срабатывания редкие, потому что само сравнение адресов “дешевле” исключения, но каждое попадание всё равно превращается в синхронный переход управления с сохранением и восстановлением контекста, поэтому наблюдение горячих адресов быстро начинает доминировать в накладных расходах.

Для инструмента мониторинга доступа к памяти в заданном контексте watchpoints хорошо закрывают режимы точечной диагностики, где важна именно точность и момент события. При этом watchpoints почти не подходят на роль универсального механизма для широкого покрытия адресного пространства процесса, и это ограничение лучше проговорить прямо, потому что оно задаётся не реализацией в ОС, а количеством аппаратных ресурсов debug unit.


=== MMU permission faults: аппаратная проверка прав страниц и исключения


MMU (Memory Management Unit) представляет собой функциональный блок процессора, реализующий виртуальную память на уровне аппаратуры, то есть отображение виртуального адресного пространства процесса на физическую память, а также применение правил доступа, заданных в структурах трансляции.  
Механизм контроля прав доступа через MMU основан на том, что для большинства современных архитектур обращение к памяти является композицией двух аппаратных процедур: трансляции виртуального адреса и проверки атрибутов доступа.  
Адресное пространство процесса организуется странично: виртуальная память разбивается на страницы фиксированного размера (типично 4 KiB), а их отображение и свойства задаются записями таблиц страниц, которые содержат как адрес целевого физического фрейма, так и набор атрибутов, определяющих допустимые операции (чтение, запись, исполнение) и режимы доступа (привилегированность, параметры кэширования и др.) @intel_sdm_vol3a_253668.

С аппаратной точки зрения каждая операция загрузки или сохранения (load/store), а также каждая выборка инструкции (instruction fetch), сопровождается обращением MMU к структурам трансляции и проверкой соответствующих атрибутов.  
Если требуемый тип доступа не разрешён текущими атрибутами страницы, процессор формирует синхронное исключение, фиксируя тем самым нарушение установленной политики доступа.  
Для x86-64 таким исключением является page fault (PF), при котором faulting linear address сохраняется в CR2 (Control Register 2), а код ошибки (PF error code) содержит диагностические признаки причины нарушения, в частности различение операций записи и, при наличии соответствующей поддержки, нарушений при выборке инструкции @intel_sdm_vol3a_253668.  
Для Armv8-A аналогичная семантика реализуется через исключения Data Abort и Instruction Abort, где класс и причина нарушения кодируются в ESR_ELx, а адрес, по которому произошёл fault, фиксируется в FAR_ELx.

TLB (Translation Lookaside Buffer) -- аппаратный кэш MMU, содержащий результаты недавней трансляции виртуальных адресов и связанные с ними атрибуты доступа, что уменьшает число обращений к таблицам страниц @scoutapm_page_faults_2019.
#figure(
  image("assets/pagefault.png"),
  caption: [Упрощённая схема трансляции адресов и возникновения page fault],
) <fig:mmu-pagefault-path>

Ключевая особенность permission faults заключается в том, что событие возникает не при любом обращении к памяти, а строго при обращении, которое противоречит текущим правам страницы.  
Это определяет типичные сценарии применения механизма в задачах мониторинга: он естественным образом подходит для выявления единичных или редких нарушений, а также для схем “first-touch”, где фиксируется первое обращение к региону памяти после принудительного ограничения прав.  
Попытка использовать permission faults как источник событий для полного логирования каждого обращения к памяти приводит к необходимости многократного переустановления запретов и тем самым к генерации исключения практически для каждой целевой операции.  
Поскольку обработка синхронного исключения включает переход управления, сохранение контекста и выполнение обработчика, накладные расходы в таком режиме становятся приблизительно пропорциональными частоте обращений к мониторируемым страницам, что делает мониторинг “каждого доступа” практически непригодным для горячих регионов памяти.

Гранулярность механизма определяется страничной организацией виртуальной памяти.  
Права доступа задаются на уровне дескрипторов страниц или блоков трансляции, поэтому единицей контроля является страница фиксированного размера или крупная страница (huge page), если такие отображения используются в системе.  
Применение больших страниц повышает эффективную гранулярность контроля и, как следствие, снижает локальность событий: одно изменение атрибутов может покрывать существенно больший диапазон адресов, чем стандартная страница.  
Одновременно страничная природа permission faults делает подход удобным в тех случаях, когда интерес представляет мониторинг доступа к целым регионам (например, сегмент данных процесса, область динамических выделений или отображение разделяемой библиотеки), а не к отдельным байтам или объектам.


==== Ловля записи/чтения через запреты на странице

Наиболее прямолинейный вариант применения permission faults в мониторинге заключается в том, что для выбранных страниц устанавливаются ограничения на чтение и/или запись.  
В таком режиме любая попытка выполнить store в страницу, помеченную как read-only, приводит к синхронному исключению, что аппаратно фиксирует факт записи в защищаемый регион.  
На x86-64 признак операции записи отражается в поле W/R кода ошибки page fault, а адрес нарушения доступен в CR2, что позволяет однозначно определить виртуальный адрес, спровоцировавший событие @intel_sdm_vol3a_253668.  
На Armv8-A аналогичный диагностический минимум формируется через связку ESR_ELx и FAR_ELx, позволяющую различать permission fault и иные причины abort, а также извлечь faulting address.

В момент события мониторинг может опираться на две группы сведений.  
Первая группа относится к памяти и включает адрес нарушения и тип операции, что позволяет привязать событие к конкретной странице и к классу доступа.  
Вторая группа относится к контексту исполнения и включает сохранённое состояние потока на момент исключения, в частности адрес инструкции, вызвавшей обращение, и набор регистров.  
Это создаёт основу для последующей атрибуции события к участку кода и для контекстной фильтрации по признакам исполнения, однако сами по себе аппаратные механизмы не предоставляют высокоуровневых идентификаторов (например, “имя функции” или “имя модуля”), и такие метаданные требуют восстановления на основе адресов и карты отображений процесса.

С точки зрения применимости к инструменту мониторинга запрет записи или чтения на уровне страниц рационально рассматривать как механизм порогового контроля.  
Он хорошо подходит для фиксации первых обращений к заранее определённым областям или для выявления редких записей в чувствительные регионы, но плохо масштабируется на сценарии, где обращения к выбранным страницам происходят с высокой частотой, поскольку стоимость обработки исключений становится доминирующей, а страничная гранулярность приводит к тому, что события могут агрегировать доступы к множеству различных объектов, размещённых в пределах одной страницы.


==== Ловля исполнения через NX/XN/PXN

Запрет исполнения страниц представляет собой специализированный частный случай permission faults, ориентированный на контроль выборки инструкций.  
NX (No-eXecute) и XD (eXecute Disable) -- обозначения механизма, при котором для страницы памяти задаётся атрибут “неисполняемая”, то есть запрещается выборка инструкций из данного диапазона.  
В контексте x86-64 принято говорить о бите NX/XD в записи таблицы страниц, а также о поддержке execute-disable на уровне архитектуры, благодаря которой попытка instruction fetch из неисполняемой страницы приводит к синхронному исключению page fault (PF).  
В этом случае нарушение можно отличить от чтения или записи по признакам кода ошибки PF, а faulting address фиксируется в CR2 @intel_sdm_vol3a_253668.

В Armv8-A эквивалентная идея выражается через атрибуты XN (eXecute Never), которые задаются в дескрипторах трансляции и запрещают исполнение из соответствующего блока или страницы.  
Для более точного разграничения режимов используются UXN (Unprivileged eXecute Never) и PXN (Privileged eXecute Never), позволяющие независимо запрещать исполнение в непривилегированном и привилегированном режимах соответственно.  
Это означает, что одна и та же область памяти может быть неисполняемой для кода пользовательского уровня и при этом оставаться исполняемой для кода более привилегированных уровней, либо наоборот, в зависимости от выбранной политики защиты @armv8a_address_translation_100940.

Данный механизм имеет высокую практическую значимость для задач информационной безопасности, поскольку предоставляет аппаратный триггер на попытку исполнения из регионов, которые по политике процесса должны интерпретироваться как данные.  
В момент события доступны адрес страницы, из которой производилась попытка выборки, и адрес инструкции, вызвавшей обращение, что позволяет реконструировать связь между исполняемым кодом и регионом памяти, нарушившим политику исполняемости @intel_sdm_vol3a_253668 @armv8a_exception_model_102412.  
Ограничения механизма совпадают с общими ограничениями permission faults: он естественно работает как детектор нарушений или как средство точечного контроля, но не подходит для получения полной трассы исполнения “по памяти”, так как попытка генерировать событие на каждую выборку приводит к неприемлемым накладным расходам из-за частых синхронных исключений.

=== Extended Page Tables
Extended Page Tables (EPT) -- это технология аппаратной виртуализации, которая позволяет ускорить трансляцию адресов в виртуализованных средах. Она добавляет второй уровень трансляции, обеспечивая перевод виртуальных адресов гостевой операционной системы в физические адреса хоста. Это осуществляется с помощью дополнительной таблицы, управляющей правами доступа для каждой страницы как для гостевой ОС, так и для хоста, что способствует изоляции и безопасности виртуализированных систем. В процессе работы, когда гостевая ОС обращается к памяти, её виртуальный адрес сначала преобразуется в guest-physical, а затем с помощью EPT -- в физический адрес хоста.

Однако EPT требует наличия аппаратной поддержки, такой как Intel VT-x @intel_sdm_vol3a_253668 или AMD-V @amd64_apm_vol2_24593_343 @armv8a_address_translation с поддержкой NPT, что ограничивает её доступность. Основные ограничения EPT включают дополнительные накладные расходы на управление двумя уровнями таблиц страниц и перехват доступа к памяти, что может замедлять работу системы, особенно при больших объёмах данных.

EPT используется для эффективного мониторинга нарушений прав доступа, таких как попытки чтения или записи в защищённые области памяти, но её использование ограничено на уровне целых страниц или диапазонов. Это делает EPT полезной для виртуализации, но менее эффективной для точного мониторинга мелких объектов памяти.

=== Сопоставление аппаратных механизмов

Пара watchpoints и permission faults покрывает два принципиально разных режима мониторинга доступа.  
Watchpoints дают адресную точность и позволяют получить событие на конкретный объект или узкий диапазон, однако ограничены малым числом аппаратных слотов и быстро становятся неэффективными при попытке масштабировать наблюдение.  
Permission faults, напротив, позволяют накрывать широкие области памяти за счёт страничной гранулярности, но событие возникает только при нарушении прав, поэтому механизм естественно подходит для режимов “first-touch” и редких триггеров, а при попытке превратить его в источник событий для каждого доступа накладные расходы растут пропорционально частоте обращений к выбранным страницам.
#pagebreak()
#figure(
  table(
    columns: 4,
    table.header(
      [Аппаратное средство],
      [Охват адресного пространства],
      [Профиль накладных расходов],
      [Типичная область применимости],
    ),

    [Watchpoints],
    [Точечный],
    [Низкие при редких срабатываниях; высокие при “горячих” адресах из-за частых исключений],
    [Точная фиксация доступа к критичным объектам],

    [PF (R/W/NX/XN/PXN)],
    [Широкий по страницам],
    [Приемлемые при редких срабатываениях],
    [Обнаружение первого срабатывания для регионов памяти],

    [EPT],
    [Виртуальное и физическое адресное пространство],
    [Низкие, благодаря аппаратной поддержке],
    [Мониторинг памяти в \ виртуал. системах, изоляция процессов],
  ),
  caption: [Сопоставление аппаратных механизмов мониторинга доступа к памяти и типичных областей применимости],
) <hw-mechanisms-comparison>

Таблица выше суммирует различия между аппаратными механизмами не в терминах их внутренней реализации, а с точки зрения практического выбора инструмента под задачу наблюдения, показывая, что решающим фактором становится не столько точность или охват сами по себе, сколько допустимый профиль накладных расходов и характер ожидаемых событий доступа.


== Инструменты и механизмы операционных систем

Операционная система Linux предоставляет несколько классов механизмов наблюдения, которые позволяют строить мониторинг памяти без внедрения кода в целевой процесс.  
Содержательно такие механизмы удобно разделять на событийные источники контекста исполнения, средства наблюдения за состоянием страниц виртуальной памяти и подсистемы, оценивающие активность диапазонов как “горячие” или “холодные”.  
В рамках инструмента мониторинга доступов к памяти эти механизмы используются не как взаимозаменяемые решения, а как комплементарные источники данных, которые совместно дают контекст, атрибуцию и управляемую точность наблюдения.


=== Событийная трассировка ядра и user-space: tracepoints/kprobes/uprobes + eBPF
Событийная трассировка в Linux строится вокруг идеи, что многие существенные переходы состояния системы могут быть представлены в виде событий, на которые можно подписаться и получать структурированную информацию о происходящем.  
Tracepoints (точки трассировки ядра) являются статически заданными событиями, встроенными в код ядра, и по этой причине рассматриваются как наиболее стабильная база для наблюдения, поскольку их семантика фиксируется разработчиками ядра и сопровождается документацией @linux_tracepoints.  
В контексте мониторинга памяти такие события полезны для построения причинно-временной картины вокруг действий процесса, включая операции управления отображениями памяти и события, связанные с системными вызовами, которые задают границы фаз выполнения.

Kprobes (динамические пробники ядра) дополняют tracepoints как механизм, позволяющий подключаться к выбранным функциям ядра в тех случаях, когда статической точки трассировки нет или её данных недостаточно @linux_kprobes.  
Такой подход расширяет наблюдаемость, однако повышает требования к инженерной аккуратности, потому что точки привязаны к конкретным адресам и символам и могут быть чувствительны к изменениям версий ядра.  
В практическом проектировании инструмента kprobes целесообразно рассматривать как средство адресного расширения покрытия, а tracepoints -- как основу, на которую опирается штатный режим мониторинга.

Uprobes (динамические пробники пользовательского пространства) позволяют ставить события на инструкции или смещения в исполняемых файлах и разделяемых библиотеках целевого процесса, тем самым вводя семантические маркеры фаз выполнения без модификации исходного кода @linux_uprobe_tracer.  
Это полезно, когда требуется связать признаки активности памяти не только с PID или TID, но и с логической фазой, например входом и выходом из аллокатора, обработчика запроса, криптографической процедуры или сериализации данных.  
В результате uprobes формируют “шкалу контекста”, на которую затем накладываются наблюдения о состоянии страниц и активности диапазонов.


eBPF (extended Berkeley Packet Filter) реализует модель “выполнить фильтрацию в ядре”: пользовательское приложение загружает небольшую программу, которая после проверки верификатором исполняется в привязанной точке (tracepoint/kprobe/uprobe) и передаёт результаты в user-space.
Обмен данными между eBPF-программами и пользовательским пространством выполняется через BPF maps (структуры хранения ключ–значение и специализированные типы), которые позволяют как сохранять агрегаты внутри ядра, так и выдавать результаты наружу без постоянной печати и форматирования в tracefs @linux_bpf_maps.  


#figure(
  image("assets/ebpf.png"),
  caption: [Обобщённая схема работы eBPF при трассировке],
) <fig:ebpf-tracing-scheme>

За счёт этого возможна контекстная фильтрация по PID (Process Identifier), TID (Thread Identifier), cgroup (control group), а также привязка событий к syscall-контексту (системный вызов) и, при необходимости, сбор диагностических признаков вроде стека выполнения @zone24x7_ebpf_tracing_2022.
С инженерной точки зрения eBPF важен тем, что позволяет ограничивать объём данных, снижать накладные расходы за счёт агрегации “на месте” и реализовывать единый механизм включения и выключения интересующих источников событий в зависимости от режима наблюдения.

При использовании описанной связки следует учитывать, что событийная трассировка не является механизмом регистрации каждого обращения load/store к памяти.  
Её роль заключается в построении контекста исполнения и в фиксации событий, которые структурируют работу процесса и задают точки корреляции с данными о страницах и диапазонах, получаемыми другими механизмами.

=== Отслеживание модификаций страниц и атрибуция регионов: soft-dirty + pagemap

Soft-dirty в Linux -- это механизм программного отслеживания записей в страницы виртуальной памяти на уровне записей таблиц страниц.  
Под страницей виртуальной памяти понимается фиксированный по размеру блок адресного пространства процесса (типично 4 KiB), а запись таблицы страниц (PTE, Page Table Entry) -- это структура, в которой для конкретной виртуальной страницы хранится информация о её отображении и атрибутах доступа.  
Soft-dirty реализуется как специальный признак в PTE, который позволяет ответить на вопрос “выполнялась ли запись в эту страницу после момента последнего сброса признаков” @linux_soft_dirty.

Сброс soft-dirty выполняется через интерфейс /proc/\<pid>/clear_refs, запись значения 4 означает “очистить soft-dirty” для страниц процесса @linux_soft_dirty @linux_proc_clear_refs @linux_proc_overview.  
Внутренне сброс не ограничивается обнулением бита.  
Документация ядра прямо указывает, что при очистке soft-dirty ядро также снимает признак writable у соответствующих PTE, временно делая страницы логически доступными только на чтение @linux_soft_dirty.  
После этого первая попытка записи в любую из таких страниц порождает page fault (страничное исключение), а обработчик исключения в ядре восстанавливает writable и одновременно выставляет soft-dirty в PTE @linux_soft_dirty.  
Ключевой смысл этого шага в том, что фиксируется именно факт первой записи в страницу в данном интервале, а не каждая отдельная операция store.

Такое поведение удобно трактовать как “срабатывание один раз на страницу в окне наблюдения”.  
Soft-dirty не хранит счётчик записей и не даёт идентификацию инструкции, которая выполнила запись, поэтому семантика остаётся бинарной: страница либо была модифицирована после сброса, либо нет.  
Важная инженерная деталь состоит в том, что возникающие после сброса page fault не означают подкачку или чтение с диска.  
В описанной схеме страницы уже отображены в память, поэтому fault используется как управляемый механизм смены прав и установки диагностического признака, что и объясняет относительную “лёгкость” такого режима при умеренном числе модифицируемых страниц @linux_soft_dirty @lwn_soft_dirty_cow_2021.

Интерфейс /proc/\<pid>/pagemap предоставляет пользователю по одному 64-битному значению на каждую виртуальную страницу, описывая её состояние и ряд признаков.  
В частности, документация ядра и man-страница фиксируют, что бит 55 в pagemap соответствует soft-dirty и отражает состояние PTE для данной страницы @linux_pagemap_kernel @linux_proc_pagemap_man.  
Эти же источники полезны тем, что задают границы применимости: pagemap доступен только при включённой конфигурации CONFIG_PROC_PAGE_MONITOR и подчиняется правилам доступа, связанным с ptrace-режимом, а получение физического номера страницы (PFN, Page Frame Number) дополнительно ограничено привилегиями (CAP_SYS_ADMIN) @linux_proc_pagemap_man @linux_pagemap_kernel.
ражения (mmap файлов и библиотек), анонимные диапазоны, стек и области, относящиеся к heap @linux_proc_maps @linux_proc_smaps.

Отдельно важно учитывать динамику адресного пространства.  
Soft-dirty привязан к PTE и, следовательно, может теряться при операциях, которые разрушают и создают записи таблиц страниц заново (например, unmap/remap), а чтобы не допускать “тихой потери” информации о обновлённых регионах, в практических описаниях механизма подчёркивается, что при переотображении ядро может заново маркировать соответствующие области как soft-dirty @criu_memory_changes_tracking.  
Это не меняет базовой семантики “страница была записана после сброса”, но требует аккуратной интерпретации при активных перестроениях карт отображений процесса.


=== Непрерывный мониторинг “горячих” диапазонов: DAMON

DAMON (Data Access MONitor) -- подсистема ядра Linux, предназначенная для оценки паттернов доступа к памяти на уровне диапазонов, включая частоту и интенсивность обращений, и для адаптивного уточнения границ наблюдаемых регионов @linux_damon.  
В отличие от механизмов, ориентированных на события нарушения прав или на точечные триггеры, DAMON описывает поведение памяти как распределение активности по диапазонам, что делает его полезным для задач ранжирования и выбора областей, требующих повышенного внимания.

Результаты DAMON удобно рассматривать как вход для управляемой эскалации детализации наблюдения.  
При выявлении подозрительного региона или нетипичного изменения профиля активности инструмент может включать более детальную трассировку через eBPF и uprobes, сокращать окно наблюдения для повышения временного разрешения, а также переходить к точечным аппаратным триггерам через интерфейсы операционной системы, например perf_event_open (hardware breakpoints).
Такой подход сохраняет практическую применимость мониторинга за счёт того, что высокозатратные режимы включаются ограниченно и адресно, а основная часть наблюдения выполняется средствами, рассчитанными на длительную работу и на обработку данных в агрегированном виде.

#pagebreak()
=== Сопоставление механизмов ОС

#figure(
  table(
    columns: 4,
    table.header(
      [Механизм ОС],
      [Охват адресного пространства],
      [Профиль накладных расходов],
      [Типичные области применимости],
    ),

    [Tracepoints/kprobes/uprobes + eBPF],
    [Событие / точка в коде],
    [Низкий--умеренный; основная стоимость определяется частотой событий],
    [Построение контекста вокруг памяти: mmap/munmap/mprotect, ошибки, I/O-фазы, фазовые маркеры],

    [Soft-dirty],
    [Широкий по выбранным VMA; страничная гранулярность (типично 4 KiB)],
    [Низкий при умеренном числе записываемых страниц;],
    [Длительное наблюдение “куда писали” и выделение регионов для углубления анализа],

    [DAMON],
    [Широкий по диапазонам (региональная модель; границы уточняются ядром)],
    [Низкий--умеренный; рост при увеличении диапозона],
    [Выбор “горячих” областей памяти, где имеет смысл повышать детализацию]
  ),
  caption: [Сопоставление механизмов ОС для мониторинга доступа к памяти и профиля накладных расходов],
) <os-mechanisms-application-table>


На практике наиболее стабильная схема для attach-модели выглядит как “контекст через trace/eBPF + следы записей через soft-dirty/pagemap + выбор горячих регионов через DAMON”, а точечные триггеры через perf_event_open используются как режим эскалации на коротком интервале, когда уже известен конкретный адрес или узкий набор страниц.  
Такое разделение ролей позволяет удерживать накладные расходы на приемлемом уровне и при этом иметь понятный путь повышения точности, когда наблюдение выявило конкретный кандидат для углублённой проверки.



== Инструменты на уровне приложений

Инструменты мониторинга памяти на уровне приложений ориентированы на наблюдение поведения конкретной программы в пользовательском пространстве и, в зависимости от класса, либо фиксируют нарушения корректности обращений к памяти, либо собирают профиль распределения памяти, либо анализируют трассы обращений на уровне отдельных инструкций.  

Ключевое различие между такими средствами заключается в том, что именно считается наблюдаемым событием и какая гранулярность доступна пользователю: нарушение доступа, вызов аллокатора, либо обращение к памяти на уровне load-инструкции.  

Для сопоставления ниже рассмотрены несколько показательных представителей, которые покрывают эти классы и хорошо иллюстрируют компромиссы между полнотой наблюдения, интерпретируемостью результатов и накладными расходами.  


=== AddressSanitizer как инструмент детектирования нарушений memory-safety

AddressSanitizer (ASan, Address Sanitizer) относится к классу санитайзеров, реализующих компиляторную инструментализацию для выявления нарушений корректности обращений к памяти.  
Механизм работы в базовой форме опирается на теневую память (shadow memory) и на внедрённые проверки, которые исполняются вместе с программой и сопоставляют фактический адрес обращения с допустимым диапазоном целевого объекта.  
Для повышения надёжности детектирования вокруг объектов формируются защитные зоны (redzones), а освобождённые области на время удерживаются в карантине, что позволяет эффективнее выявлять use-after-free, когда обращение происходит вскоре после освобождения @serebryany_asan_2012.  

Событием для ASan является обнаружение обращения, противоречащего модели допустимых адресов, то есть ошибка фиксируется в момент выполнения проблемной операции.  
Результат наблюдения представлен диагностическим отчётом, в который обычно входят адрес нарушения, тип дефекта и контекст исполнения, причём контекст чаще всего задаётся стеком вызовов (stack trace), позволяющим привязать ошибку к месту в исходном коде или к символам бинаря. @serebryany_asan_2012  

Типичные сценарии использования ASan связаны с тестированием и регрессионной проверкой, где важнее систематическая обнаруживаемость дефектов, чем сохранение исходного профиля производительности.  
Существенным ограничением является необходимость собирать целевой бинарный файл с включённой инструментализацией и учитывать изменение профиля потребления ресурсов из-за проверок и поддержания метаданных. @serebryany_asan_2012  


=== Valgrind Memcheck как эталонный dynamic checking на базе DBI

Valgrind представляет собой фреймворк динамической бинарной инструментализации (DBI, Dynamic Binary Instrumentation), в рамках которого исполнение программы переводится в управляемую форму и сопровождается добавлением проверок и учётом дополнительных состояний. @nethercote_valgrind_2007  
Memcheck является наиболее известным инструментом поверх Valgrind, предназначенным для выявления широкого класса ошибок работы с памятью, включая обращения к невалидным адресам и использование неинициализированных данных. @valgrind_manual  

Функциональная особенность Memcheck состоит в том, что он поддерживает теневое представление состояния памяти, отслеживая адресуемость и инициализацию на уровне выполнения, что делает его диагностику особенно полезной в сценариях, где дефект проявляется не сразу и зависит от конкретной траектории исполнения. @valgrind_manual  
События в Memcheck возникают при выполнении операции, нарушающей отслеживаемые инварианты, а отчёт обычно включает описание типа дефекта и привязку к месту выполнения с контекстом, достаточным для практической локализации причины.

Компромисс DBI-подхода заключается в высоких накладных расходах, поскольку существенная часть исполнения проходит через слой инструментализации и сопровождается обновлением теневого состояния. @nethercote_valgrind_2007  
По этой причине Memcheck принято рассматривать как эталон точности для подтверждения гипотез о дефектах, а не как инструмент длительного мониторинга в условиях чувствительности к производительности.


=== Heaptrack как профилирование динамических выделений памяти

heaptrack относится к инструментам профилирования динамических выделений, то есть к средствам, которые наблюдают события распределения памяти аллокатором и агрегируют информацию о выделениях и освобождениях @heaptrack_repo. 
В отличие от средств класса memory-safety checking, здесь наблюдаемой единицей является не обращение к произвольному адресу, а событие выделения или освобождения, которое имеет понятную семантику на уровне приложения и естественно связывается с точками вызова (call sites).  

Основной практический эффект heaptrack заключается в высокой интерпретируемости результатов.  
Так как наблюдаются события аллокаций, инструмент позволяет выявлять источники роста памяти, пики и удержание, связывая их с конкретными цепочками вызовов и компонентами программы @heaptrack_repo. 
Подобный профиль особенно полезен, когда требуется объяснить изменение потребления памяти через логику работы приложения, а не через низкоуровневые адреса страниц.  

Ограничение данного класса инструментов состоит в том, что они не предназначены для регистрации обращений load/store к уже выделенным данным и, следовательно, не дают прямого ответа на вопросы о паттернах чтения и записи внутри объектов, если эти паттерны не проявляются через дополнительные аллокации или освобождения.


=== MemGaze как анализ трасс обращений к памяти на уровне load-инструкций

MemGaze относится к исследовательским инструментам анализа трасс обращений к памяти на уровне load-инструкций, то есть операций чтения данных из памяти, представимых в виде последовательности событий “инструкция прочитала данные по адресу A” с привязкой к контексту выполнения.  
Ключевая идея MemGaze состоит в том, чтобы получать детализированный адресный след чтений без перехода к полностью программной эмуляции или тотальной динамической инструментализации, которые обычно резко увеличивают накладные расходы. @memgaze_cluster_2022  

Метод MemGaze опирается на аппаратную трассировку исполнения Intel PT (Intel Processor Trace) и на вставку в поток трассировки специальных программных маркеров через инструкцию ptwrite.  
Intel PT обеспечивает высокоскоростной сбор информации о ходе выполнения (прежде всего о переходах управления), а ptwrite позволяет добавлять в этот поток дополнительные значения, порождённые программой, в частности адреса, относящиеся к интересующим обращениям к памяти @memgaze_cluster_2022.  
За счёт такого совмещения аппаратного канала трассировки и программных маркеров MemGaze реализует “облегчённую” трассу обращений: фиксируется не каждый микрошаг работы процессора, а выбранный слой событий, достаточный для анализа поведения чтений данных. 

#figure(
  image("assets/memgaze.png"),
  caption: [Схема работы MemGaze],
) <fig:memgaze-workflow>

Типовой конвейер MemGaze можно описать как последовательность из трёх стадий @memgaze_cluster_2022.  
На первой стадии выполняется инструментирование, где в выбранные точки исполнения добавляются операции, передающие необходимые значения (например, адреса чтения) в поток трассировки через ptwrite. @memgaze_cluster_2022  
На второй стадии собирается lightweight memory trace, то есть компактный поток событий, который извлекается из PT-данных и затем декодируется в последовательность обращений, пригодную для аналитической обработки. @memgaze_cluster_2022  
На третьей стадии выполняется memory and data analysis, где по трассе вычисляются характеристики повторного использования и перемещения данных, свойства временной и пространственной локальности, а также выявляются регулярные и нерегулярные паттерны обращений. @memgaze_cluster_2022  

Событие в данной постановке соответствует обращению чтения, а ценность подхода определяется тем, что адресные трассы позволяют анализировать поведение памяти в терминах паттернов и повторного использования, которые принципиально трудно восстановить только из профилей аллокаций или из редких диагностических срабатываний. @memgaze_cluster_2022  
Ограничения подобных решений связаны с требованиями к среде трассировки и объёму обрабатываемых данных, поскольку переход к гранулярности уровня инструкций генерирует существенно более насыщенный поток наблюдений, чем аллокационное профилирование или отчёты о дефектах memory-safety.

=== Сравнение инструментов

Рассмотренные инструменты естественно формируют три разных уровня наблюдаемости:  

+ ASan и Memcheck ориентированы на детектирование нарушений корректности обращений к памяти и дают наиболее прямую диагностику дефектов memory-safety, но различаются способом достижения эффекта: ASan делает это через компиляторную инструментализацию, а Memcheck -- через выполнение под DBI-слоем @serebryany_asan_2012 @nethercote_valgrind_2007 @valgrind_manual;

+ heaptrack фиксирует события аллокации и освобождения и потому лучше отвечает на вопросы об источниках роста потребления памяти и удержания объектов, чем на вопросы о реальных паттернах чтения и записи внутри выделенных областей @heaptrack_repo;

+ MemGaze ориентирован на анализ адресных трасс на уровне load-событий, что делает его наиболее информативным для исследований паттернов доступа, но одновременно повышает требования к условиям трассировки и к обработке значительных объёмов данных @memgaze_cluster_2022.
#pagebreak()
#figure(
  table(
    columns: 4,
    table.header(
      [Название инструмента],
      [Тип наблюдаемых событий],
      [Доступный контекст],
      [Профиль накладных расходов],
    ),

    [ASan],
    [Ошибки memory-safety],
    [Стек вызовов, адрес нарушения, тип дефекта],
    [Умеренный; зависит от плотности проверок и объёма данных],

    [Valgrind Memcheck],
    [Ошибки памяти при выполнении],
    [Детализированная диагностика с привязкой к месту выполнения, типу дефекта и адресу],
    [Высокий; определяется DBI и поддержанием теневого состояния],

    [heaptrack],
    [Call site аллокации/освобождения],
    [Цепочка вызовов и агрегаты по точкам выделения],
    [Низкий--умеренный; определяется частотой аллокаций и глубиной сбора стека],

    [MemGaze],
    [Обращение load-уровня (load-level trace)],
    [Адресный след чтений и производные метрики локальности/reuse],
    [Переменный; зависит от режима трассировки Intel PT/ptwrite],
  ),
  caption: [Сопоставление гранулярности наблюдения, доступного контекста и профиля накладных расходов],
) <app-tools-observability-cost>

#pagebreak()
#figure(
  table(
    columns: 4,
    table.header(
      [Название инструмента],
      [Модель внедрения],
      [Без изменения целевого процесса],
      [Типичные сценарии использования],
    ),

    [ASan],
    [Пересборка с\ инструмента-\ лизацией],
    [Нет],
    [CI и регрессионные тесты, fuzzing],

    [Valgrind Memcheck],
    [Запуск под рантаймом DBI],
    [Частично (запуск под инструментом)],
    [Точная отладка],

    [heaptrack],
    [Запуск в подготовленном окружении],
    [Частично (требуется контроль окружения запуска)],
    [Поиск причин роста памяти, пики, удержание],

    [MemGaze],
    [Инструменти-\рование + сбор PT-трассы и последующий анализ],
    [Частично (зависит от условий трассировки и режима запуска)],
    [Анализ паттернов чтения, локальности и повторного использования],
  ),
  caption: [Сопоставление модели внедрения, применимости без модификации процесса и сравнение типичных сценариев],
) <app-tools-integration-usage>

Сопоставление в таблицах показывает характерную зависимость между точностью анализа и скоростью работы инструментов мониторинга памяти на уровне приложений.  

При повышении точности обычно растёт частота и “близость” вмешательства в путь исполнения, а вместе с этим увеличиваются накладные расходы.  
Memcheck, который строит модель адресуемости и инициализации на уровне динамической бинарной инструментализации, даёт наиболее детальную и универсальную диагностику, но сопровождается высокой стоимостью из-за постоянного инструментирования инструкций и обновления теневого состояния. @nethercote_valgrind_2007 @valgrind_manual  

В практическом обзоре эти инструменты целесообразно воспринимать как взаимодополняющие подходы.  
Они закрывают разные классы задач и демонстрируют разные компромиссы между точностью диагностики, объяснимостью результатов и накладными расходами, что задаёт основу для выбора критериев и требований к системам мониторинга памяти в дальнейших разделах.  

== Выводы
В этой главе был проведён сравнительный анализ различных инструментов и технологий для мониторинга памяти, охватывающих как аппаратные механизмы, так и программные решения, встроенные в операционные системы и приложения. Инструменты мониторинга памяти можно классифицировать на:

- аппаратные механизмы (watchpoints, permission faults) -- для точечной диагностики и мониторинга доступа к памяти с высокой точностью, но с ограничениями по числу слотов и накладным расходам при масштабировании. Extended Page Tables (EPT) контролируют доступ к памяти на уровне гипервизора, что позволяет эффективно управлять виртуальной памятью в виртуализированных системах;

- механизмы ОС (tracepoints, kprobes, eBPF, soft-dirty, DAMON) -- для мониторинга состояния памяти и активности процессов с контекстной фильтрацией, позволяя выявить "горячие" области и адаптивно увеличивать детализацию;

- инструменты на уровне приложений (ASan, Memcheck, heaptrack, MemGaze) -- для детектирования нарушений работы с памятью и анализа паттернов доступа с учетом производительности и накладных расходов.

Внутри каждой из этих категорий инструменты были сравнены между собой по различным параметрам, таким как точность, накладные расходы и область применения. Результаты сравнений представлены в таблицах, включая таблицу сравнения аппаратных механизмов (таблица @hw-mechanisms-comparison), таблицу сравнения механизмов ОС (таблица @os-mechanisms-application-table) и таблицу сравнения инструментов на уровне приложений (таблица @app-tools-observability-cost), что позволяет сделать обоснованный выбор в зависимости от целей мониторинга.

В результате проведенного анализа инструментов и технологий мониторинга памяти можно выделить несколько ключевых выводов:

Во первых, чем более детализированное наблюдение требуется (например, на уровне инструкций), тем выше накладные расходы. Memcheck и Valgrind предлагают высокую точность, но имеют значительные затраты ресурсов. Heaptrack и MemGaze предлагают более легкие альтернативы для профилирования памяти, но с меньшей точностью.

Во вторых, для эффективного мониторинга лучше всего использовать комбинацию различных инструментов, в зависимости от конкретных целей и задач. Например, tracepoints и eBPF обеспечивают контекстную фильтрацию, а watchpoints и permission faults могут быть использованы для точечных триггеров.