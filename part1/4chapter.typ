= Проектирование архитектуры на концептуальном уровне

Проектирование архитектуры инструмента мониторинга памяти является ключевым этапом, переходящим от требований (сформулированных в главе 3) к конкретному решению, позволяющему эти требования реализовать. Целью архитектурного проектирования на концептуальном уровне является определение структуры системы – набора модулей и взаимодействий между ними – таким образом, чтобы обеспечить выполнение всех функциональных возможностей, ожидаемых от инструмента. Архитектура разрабатываемого средства будет модульной, что означает логическое разделение системы на уровни с чётко очерченными ответственностями. . Данный подход обеспечивает изоляцию низкоуровневых механизмов перехвата событий от высокоуровневого представления данных пользователю, упрощает модификацию и расширение системы. В контексте поставленных требований это означает, что каждому важному аспекту функциональности будет соответствовать отдельный модуль или подсистема.

== Блок-схема алгоритма работы инструмента мониторинга памяти
Прежде всего, рассмотрим общий алгоритм работы инструмента мониторинга памяти на концептуальном уровне. Ниже описана последовательность шагов, которую выполняет система при запуске мониторинга, включая два варианта начала работы: запуск целевого приложения под контролем инструмента (режим launch) и подключение к уже запущенному процессу (режим attach). В обоих случаях пользователь инициирует сеанс мониторинга через интерфейс, указывая необходимый режим и параметры (идентификатор процесса или путь к исполняемому файлу, а также критерии фильтрации событий). Инструмент либо запускает процесс под своим контролем, либо подключается к существующему, после чего настраивает средства перехвата событий памяти. 

Далее целевой процесс исполняется, и инструмент в режиме реального времени перехватывает события доступа к памяти (чтение, запись, исполнение инструкций). Каждое событие проходит через блок фильтрации: проверяется, соответствует ли оно заданным пользователем условиям (по потоку, модулю, адресу и т.п.). Если событие удовлетворяет активным фильтрам, инструмент осуществляет регистрацию (запись) события – сохраняет информацию о нем в структуру результатов и/или выводит пользователю согласно настройкам. Если событие не попадает под заданные критерии, оно отбрасывается и не нагружает вывод.

Такой цикл перехвата и фильтрации повторяется для всех поступающих событий, пока пользователь не остановит мониторинг. При получении команды остановки инструмент отключается от процесса (или завершает запущенный процесс, если работал в режиме launch) и формирует отчёт.
#figure(
image("assets/block.png", width: 80%),
caption: [Блок-схема алгоритма работы инструмента мониторинга памяти]
)

== Основные модули планируемой архитектуры
Исходя из функциональных требований, сформулированных ранее, разработанная архитектура разделяется на несколько основных модулей, каждый из которых отвечает за свой участок работы инструмента. Такая организация позволяет отнести эти компоненты к различным логическим уровням системы – от низкоуровневого взаимодействия с ОС до интерфейса с пользователем. Ниже перечислены основные модули предлагаемой архитектуры, их функции и положение в общей иерархии:

*Модуль перехвата событий*. Отвечает за перехват событий доступа к памяти целевого процесса. Этот модуль инициализирует мониторинг: в режиме launch запускает приложение под отладочным контролем, в режиме attach – подключается к уже работающему процессу. Далее модуль перехвата устанавливает необходимые механизмы слежения за памятью, чтобы получать уведомления о событиях. Перехваченные события в сыром виде (с указанием адреса, типа доступа, идентификаторов процесса и потока) передаются на следующий уровень обработки. Модуль реализует функциональное требование *регистрации событий активности памяти*, обеспечивая фиксацию всех происходящих событий заданного класса.

*Модуль фильтрации*. Реализует контекстную фильтрацию событий согласно критериям, заданным пользователем. Он принимает события (вместе с их атрибутами) и проверяет, удовлетворяют ли они активным фильтрам: по идентификатору потока, по принадлежности адреса к определённому модулю или диапазону памяти, по типу события и другим условиям (как указано в требованиях, фильтрация должна допускать комбинацию критериев с логическим AND/OR). Модуль фильтрации отбрасывает события, не соответствующие условиям, предотвращая их попадание в результирующий вывод, и пропускает дальше только релевантные данные. Таким образом, реализуются функциональные требования по фильтрации по потоку, модулю, адресу, а также требование поддержки комбинации фильтров (одновременное применение нескольких критериев).

*Модуль контекстной атрибуции* – также относится к уровню обработки событий и тесно взаимодействует с модулем фильтрации (возможно, интегрируясь с ним в рамках общего процесса обработки). Его функция – обогащение каждого перехваченного события дополнительной контекстной информацией, повышающей ценность данных мониторинга. В частности, модуль атрибуции определяет, к какому компоненту или области памяти относится адрес события: например, сопоставляет адрес с загруженным модулем или сегментом (код, куча, стек и т.д.), идентифицирует библиотеку или исполняемый файл, откуда произошёл доступ. Эта информация затем используется модулем фильтрации (для принятия решения) и модулем хранения результатов (для формирования отчёта). Модуль контекстной атрибуции реализует потребность в привязке события к контексту выполнения, подчеркнутую в пользовательских требованиях, и формирует полный состав записи о событии

*Модуль хранения результатов* – отвечает за накопление и структурирование данных о событиях, прошедших через фильтр, и относится к уровню управления данными системы. Он сохраняет отфильтрованные события в требуемом формате и предоставляет их для вывода. В простейшем случае данный модуль может формировать журнал (лог-файл) или таблицу событий, включающую ключевые поля (время, адрес, тип доступа, контекст и пр.), либо хранить данные в памяти до запроса.

*Модуль пользовательского интерфейса* – расположен на верхнем уровне архитектуры (уровень взаимодействия с пользователем) и обеспечивает интерфейс управления и представления данных. Он предоставляет средства для конфигурирования инструмента и отображения результатов. С одной стороны, интерфейс позволяет пользователю задать все необходимые параметры мониторинга: указать целевой процесс (имя исполняемого файла для запуска или PID для подключения), выбрать режим работы (launch или attach), а также установить критерии фильтрации (например, через опции командной строки, файл конфигурации или интерактивные команды). Это удовлетворяет пользовательские требования по конфигурируемости и удобству использования инструмента без необходимости менять исходный код целевого приложения. С другой стороны, модуль интерфейса отвечает за вывод собранной информации пользователю: он получает структурированные данные от модуля хранения и отображает их в понятном виде – например, выводит на консоль таблицу событий или генерирует отчет.

Логическая организация модулей по уровням такова, что поток данных идет снизу вверх: от перехвата низкоуровневых событий к их фильтрации и обогащению контекстом, затем к сохранению и отображению. Одновременно команды и настройки идут от пользователя сверху вниз: интерфейс инициирует запуск/подключение и задаёт параметры для глубинных модулей. Таким образом, модульно-слойная архитектура обеспечивает ясное разграничение: каждый уровень решает свой класс задач и взаимодействует с соседними слоями через чётко определённые интерфейсы.

== Взаимодействие модулей
На основе архитектуры, описанной выше, можно проследить, как данные и управляющие команды проходят через систему от начала до завершения мониторинга. Ниже представлена диаграмма последовательности, демонстрирующая обмен сообщениями между пользователем и основными модулями инструмента во времени.

#figure(
image("assets/sequence.png", width: 90%),
caption: [UML-диаграмма последовательности взаимодействия]
)

Диаграмма последовательности отображает детализированное взаимодействие между ключевыми модулями инструмента на протяжении всего процесса мониторинга памяти. Каждый модуль выполняет свою роль в обработке событий памяти, начиная с инициализации инструмента пользователем и заканчивая выводом результатов обратно в интерфейс.

Модуль интерфейса служит связующим звеном между пользователем и системой, принимая команды и инициируя процесс мониторинга. Модуль перехвата ответственен за захват событий доступа к памяти, а модуль контекстной атрибуции связывает эти события с конкретными потоками и модулями. Далее, модуль фильтрации применяет заранее заданные фильтры, чтобы сузить область наблюдения и отфильтровать нерелевантные данные, и, наконец, модуль хранения сохраняет нужную информацию, передавая её обратно в интерфейс для отображения пользователю.

Процесс мониторинга продолжается в цикле до тех пор, пока пользователь не завершит его, что позволяет эффективно отслеживать и анализировать события в реальном времени. Это взаимодействие между модулями делает инструмент гибким и эффективным в решении задач мониторинга памяти.

== Выводы
В данной главе был разработан концептуальный проект архитектуры инструмента мониторинга памяти, опирающийся на требования, сформулированные ранее. Предложенная архитектура имеет модульную организацию и обеспечивает соответствие поставленным целям: каждый модуль отвечает за свою функцию, а совместная работа модулей покрывает все необходимые аспекты (перехват событий, контекстная фильтрация, атрибуция и вывод результатов). 

Были получены и представлены три диаграммы, иллюстрирующие различные взгляды на архитектуру инструмента: 
- блок-схема алгоритма отражает последовательность операций инструмента, включая альтернативные режимы запуска и цикл обработки событий доступа к памяти;
- диаграмма последовательности показывает обмен сообщениями между пользователем и основными модулями во времени, шаг за шагом.

Эти визуальные модели подтверждают целостность и согласованность архитектуры: все заявленные функциональные блоки интегрированы в единое целое, а их взаимодействие организовано логично и эффективно. Таким образом, концептуальный уровень проектирования завершён – определена структура системы, которая в последующих этапах может быть развёрнута в детальную реализацию и прототип инструмента, удовлетворяющего предъявленным
